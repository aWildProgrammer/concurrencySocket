#### PHP实现的超轻量SOCKET CLIENT端连接池 实现非阻塞并发套接字

目前我实现的是SOCKET的CLIENT端，正好准备应用到公司的项目中。主要用于向外部的服务器大批量提交实时数据。服务器端代码实现也是一样的原理。当前的socket client代码非常简洁，它实现的原理是一次性创建多个SOCKET CLIENT进行远程端口监听，并将这些创建好的连接保存到数组中重复使用。

当有新任务需要发送时，将数据直接放入这个数组实现的超轻量连接池中即可。

```
// 指定一次创建100个连接
$this -> socketsAmount = 100;

// 初始化各个连接
$this -> init();
```

因为受到语言影响，一次性创建过多的连接将可能导致底层句柄初始化失败的问题，因此代码中特地加入了延时usleep(30)。经过查询后确认这是一个PHP的BUG。而且在10年前就有人提交了BUG说明。

在测试中每秒发送30万条数据，有大约千分之一的几率会出现粘包，为了避免此问题，在sendMessage()函数中加入固定的延时100微秒。

```
// 为了附上粘包 加上一个非线程安全的延迟时间
usleep(100);

// 调用示例：
$scs = new concurrencySocket;

// 每秒发送30万条信息
// 测试10分钟 未出现一次粘包
while(1) {

    for ($i = 0; $i < 300000; $i ++) {
        $scs -> sendMessage($i);
    }
    sleep(1);
}
```
